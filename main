import os
import pyaudio
import wave
import numpy as np
import speech_recognition as sr
import time
import datetime
import pyttsx3
import pyautogui
import keyboard
import subprocess
import psutil
import webbrowser
import json
import sounddevice as sd
import speech_recognition as sr
from pynput.keyboard import Key, Controller
from pynput import keyboard
import re
import json
import threading
#import ml

chrome_path = "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"

#Initializing the pyttsx3 engine
engine = pyttsx3.init('sapi5')
voices = engine.getProperty('voices')
engine.setProperty('voice', voices[0].id)
# Adjust the speech rate
engine.setProperty('rate', 150) 

#Function to speak the given text
def speak(audio):
    engine.say(audio)
    engine.runAndWait()

#Function to check if a given process is running
def is_process_running(process_name):
    return any(process_name.lower() in p.name().lower() for p in psutil.process_iter(['name']))

#Loading commands from JSON
with open('commands.json', 'r') as file:
    commands = json.load(file)

keyboard_controller = Controller()

def handle_dynamic_search(text, commands):
    """Attempt to handle dynamic search commands."""
    for command_key, command_details in commands.items():
        if command_details.get('action') == 'dynamic_search' and command_key.lower() in text.lower():
            pattern = re.compile(re.escape(command_key) + r'\s(.+)', re.IGNORECASE)
            match = pattern.search(text)
            if match:
                search_query = match.group(1).strip()
                search_url = command_details['base_url'].format(search_query)
                webbrowser.open(search_url)
                print(f"Opening {search_url}")
                return True
    return False

def execute_hotkey(keys):
    for key in keys:
        if hasattr(Key, key):  # If it's a special key
            key_to_press = getattr(Key, key)
        else:
            key_to_press = key  # Directly use the key if it's not a special key
        keyboard_controller.press(key_to_press)
        keyboard_controller.release(key_to_press)

def audio_callback(recognizer, audio, language_choice):
    try:
        text = recognizer.recognize_google(audio, language=language_choice)
        print(f"Google Speech Recognition thinks you said '{text}'")

        # Attempt to handle dynamic search commands first
        if not handle_dynamic_search(text, commands):
            # If not a dynamic search, process other command types
            for command_key, command_details in commands.items():
                if command_key.lower() in text.lower():
                    action = command_details['action']
                    if action == 'hotkey':
                        execute_hotkey(command_details['keys'])
                    elif action == 'subprocess':
                        # Execute subprocess command
                        subprocess_command = command_details['command']
                        subprocess.run(subprocess_command, shell=True)
                    print(f"Executing {action} for {command_key}")
                    break
            else:
                print("Command not found.")
    except sr.UnknownValueError:
        print("Google Speech Recognition could not understand audio")
    except sr.RequestError as e:
        print(f"Could not request results from Google Speech Recognition service; {e}")


#Main function + Function for determine time of day and greet the user
def main():
    def listen_for_trigger_word(EVA):
        # Function implementation will go here once implemented 
        pass

    trigger_detected = listen_for_trigger_word('EVA')
    if trigger_detected:
        print("Eva activated")
        speak("Eva activated")

    current_hour = datetime.datetime.now().hour
    greeting = "Good Morning!" if current_hour < 12 else "Good Afternoon!" if current_hour < 18 else "Good Evening!"

    print(greeting)
    speak(greeting)

    print("I am your Assistant EVA for today.")
    speak("I am your Assistant EVA for today.")

    recognizer = sr.Recognizer()
    print("Choose a language from English or Spanish to get started.")
    # Calling speak right after print to minimize delay
    speak("Choose a language from English or Spanish to get started.")
    language_choice = get_language_choice(recognizer)

    if language_choice:
        message = f"You have selected {'English' if language_choice == 'en-US' else 'Spanish'}. I am ready to receive your commands."
        print(message)
        speak(message)
        continuous_listen_and_act(language_choice)
    else:
        print("Failed to select a language. Exiting.")
        speak("Failed to select a language. Exiting.")

#Function to get language choice from the user using speech recognition
def get_language_choice(recognizer):
    while True:
        try:
            with sr.Microphone() as source:
                print("Listening for language choice...")
                audio = recognizer.listen(source, timeout=5, phrase_time_limit=5)
                choice = recognizer.recognize_google(audio).lower()
                if 'english' in choice:
                    return 'en-US'
                elif 'espaÃ±ol' in choice or 'spanish' in choice:
                    return 'es-ES'
                else:
                    speak("Sorry, I didn't understand. Please say English or Spanish.")
                    print("Sorry, I didn't understand. Please say English or Spanish.")
        except sr.UnknownValueError:
            speak("Sorry, I couldn't understand that. Please say English or Spanish.")
            print(  "Sorry, I couldn't understand that. Please say English or Spanish.")
        except sr.RequestError as e:
            print(f"Could not request results; {e}")

def listen_in_background(trigger_word="EVA"):
    recognizer = sr.Recognizer()
    microphone = sr.Microphone()
    
    def callback(recognizer, audio):
        try:
            speech_as_text = recognizer.recognize_google(audio)
            if trigger_word.lower() in speech_as_text.lower():
                print("EVA activated")
                speak("EVA activated")
                # Here, add any actions to perform upon activation
        except (sr.UnknownValueError, sr.RequestError):
            pass

    with microphone as source:
        recognizer.adjust_for_ambient_noise(source)
        stop_listening = recognizer.listen_in_background(microphone, callback)

    return stop_listening  # Return the stop function if needed to stop listening

        # This is just to keep the program running
    import time
    while True:
        time.sleep(0.1)

#Function to continuously listen for commands and act on them
def continuous_listen_and_act(language_choice):
    recognizer = sr.Recognizer()
    while True:
        print("Please say a command...")
        with sr.Microphone() as source:
            recognizer.adjust_for_ambient_noise(source)  # Adjusting for ambient noise can improve recognition
            audio = recognizer.listen(source, timeout=10, phrase_time_limit=10)
            audio_callback(recognizer, audio, language_choice)
            try:
                recognized_text = recognizer.recognize_google(audio, language=language_choice)
                print("Transcription: " + recognized_text)
                
                if recognized_text.lower() == "stop":
                    print("Stopping.")
                    break
            except sr.UnknownValueError:
                print("Colud not understand audio")
            except sr.RequestError as e:
                print(f"Could not request results from Google Speech Recognition service; {e}")

if __name__ == "__main__":
    main()
